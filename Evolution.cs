﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using System.Diagnostics;
public class Evolution : MonoBehaviour
{   
    //the pathFinding script
    private PathFinding astarScript;
    //the grid script
    private Gridi gridScript;
    //the mutation rate
    private int mutRate = 1;
    //the path generated by the a* that will be used as goals
    private Queue<Node> pathQueue;
    //stopwatch to record the time elapsed during the simulation
    private Stopwatch sw;
    //the filename where the experiment results will be stored in the case of a limited amount of generations
    public string fileName = "experimentLog";
    //the streamWriter to save the log
    private StreamWriter logFile;
    //robot is the whole sctructure created by createScene beggining by the robot's base
    public GameObject robot;
    //the gameobject working as the objective, its 3d position is changed and used for the fitness calculations
    public GameObject goal;
    //this is a list containing the robot's current angles
    private List<float> robotState = new List<float>();
    //this is the population, all the possible solutions for the problem
    private List<List<float>> popStates = new List<List<float>>();

    // Evolution parameters

    //N is the number of joints
    private int N = 0;
    //how many individuals in the same population, to be determined by each experiment configuration
    public int popSize;
    //the maximum possible change in a joint's angulation, the lower the more of a robotic like movement
    public float maxStep;
    //a variable to mark what the current generation is
    private int generation = 1;
    //not used at the moment, its future use will be the speed to change between each point of the path found as the goal
    public int generationsPerObjective = 20;
    //how many generations will be calculated for the experiment, -1 means undefined or neverending simulation
    public int maxGenerations = -1;
    // List of arm parts from CreateScene
    private List<GameObject> armParts;
    //this segmentLength should match distJoint in createScene, as it does in the awake method
    private float segmentLength = 0.4f;
    //just a variable to determine if an individual is better or worse than the previous best one
    private float previousBestfitness;
    public List<GameObject> obstaclesList = new List<GameObject>();

    void Awake(){
        //gets the relevant infos from the createscene and pathFinding script
        N = GetComponent<CreateScene>().N;
        armParts = GetComponent<CreateScene>().armParts;
        segmentLength = GetComponent<CreateScene>().distJoints;
        astarScript = GetComponent<PathFinding>();
        gridScript = GetComponent<Gridi>();
        //start to write into the file
        if(maxGenerations != -1) {
            sw = new Stopwatch();   
            logFile = new StreamWriter(fileName, false);
        }
        //initialize the lists with a 0 angulation
        for (int i = 0; i < N; i++){
            robotState.Add(0);
        }
        //iniitialize a random population
        for(int i=0; i<popSize; i++){
            popStates.Add(new List<float>());
            for (int j= 0; j < N; j++){
                float angle = Random.Range(-maxStep + robotState[j], maxStep + robotState[j]);
                popStates[i].Add(angle);
            }
        }
        //disables the script to wait for the pathFinding algorithm to do its job
        this.enabled = false;
    }

    //activates the Update method allowing it to happen, used by the PathFinding script to start the evolution script
    public void activate() {
        this.enabled = true;
        //gets the path found by the a* algorithm and enqueue them into the queue
        pathQueue = new Queue<Node>();
        List<Node> aux = astarScript.answerPath();
        aux.ForEach(pathQueue.Enqueue);
        //already sets the goal as the first element of the path
        goal.transform.position = pathQueue.Dequeue().worldPosition;
        //starts the time count
        if(maxGenerations != -1)
            sw.Start();
    }
    //the never ending loop of evaluating a population, displaying the best configuration and generating a new population based on the previous best one
    void Update(){
        //if this happens, it means it's time to use the next point in the path as the goal and so I update the goal
        if(generation % generationsPerObjective == 0) {
            if(pathQueue.Count != 0) {
                Node aux = pathQueue.Dequeue();
                goal.transform.position = aux.worldPosition;
            }
        }
        fitnessEvaluation();
        showArm();
        newPopulation();
        checkObstacles(); 
        //prints the generation and best fitness, i intend to make this to be written into a text file for another program to read and plot
        if(maxGenerations != -1) {
            //makes the update method stop when a certain number of generations is reached
            logFile.WriteLine(generation + ", " + previousBestfitness);
            if(generation >= maxGenerations) {
                //writes data to the file and closes it
                endProgram();
            }
        }
        generation++;
    }

    public void addObstacle(GameObject a) {
        a.transform.hasChanged = false;
        obstaclesList.Add(a);
    }
    
    void checkObstacles() {//checks if an obstacle has moved
        foreach(GameObject obstacle in obstaclesList) {
            if (obstacle.transform.hasChanged == true) {
                gridScript.createGrid();
                obstacle.transform.hasChanged = false;
            }
        }
    }

    void endProgram() {
        sw.Stop();
        logFile.WriteLine("Time elapsed(ms): " + sw.ElapsedMilliseconds);
        logFile.WriteLine("Generations: " + maxGenerations);
        logFile.WriteLine("Number of joints: " + N);
        logFile.WriteLine("Population size: " + popSize);
        logFile.WriteLine("MaxStep: " + maxStep);
        logFile.WriteLine("Generations per objective: " + generationsPerObjective);
        logFile.WriteLine("Segment lenght: " + segmentLength);
        logFile.WriteLine("Minimum obstacle distance: " + distanceObstacles(robotState));
        logFile.Close();
        logFile.Dispose();
        this.enabled = false;
    }

    void fitnessEvaluation() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        //the distance to obstacles is now also taken into account to determine the fitness.
        //this calculation is needed in the case of the goal moving, so that the bestFitness is recalculated, if it were a gloval variable and this wasn't done, it would save a fitness from a different goal or, in other words, another problem
        float distAux = distanceObstacles(robotState);//calculated only once, as this is the most CPU expensive element of the calculation
        float bestFitness;
        bool considerObstacles = false;
        if(distAux < segmentLength) {
            bestFitness = 1/Vector3.Distance(simulatedArm(robotState), goal.transform.position) - distAux - distanceObstaclesFromPoint(simulatedArm(robotState))/10; //simplified the calculation and have unlimited both parts of the fitness calculation
            considerObstacles = true;
        }
        else
            bestFitness = 1/Vector3.Distance(simulatedArm(robotState), goal.transform.position);
        //this fitness calculation takes the distance to objectivo into a max value capped when the distance is smaller than a fourth of the distJoint and tops the distance to obstacles to a max of distJoint so that it wont get any more value of getting further than a joint distance
        for (int i = 0; i < popSize; i++){
            // Test individual arm end position
            Vector3 endPosition = simulatedArm(popStates[i]);
            //calculated the fitness, or distance to the goal
            float fitness;
            //calculated only once, as this is the most CPU expensive element of the calculation 
            if(considerObstacles){
                float distAux2 = distanceObstacles(popStates[i]);
                
                fitness = 1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position) - distAux2 - distanceObstaclesFromPoint(simulatedArm(popStates[i]))/10; // also considering the tip of the arm, but in a lower cost
            }
            else
                fitness = 1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position);
            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<float>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    float distanceObstaclesFromPoint(Vector3 point) {
        Node place = gridScript.NodeFromWorldPoint(point);
        return place.layer * gridScript.nodeDiameter * segmentLength;
    }

    float distanceObstacles(List<float> angles) {
        if(obstaclesList.Count == 0) return 0; //a 0 value means no obstacle exists and thus it shouldn't be considered
        GameObject baseRobot = robot.transform.GetChild(0).gameObject;
        Vector3 position = baseRobot.transform.position;
        //the cumulative rotation starts with the identity
        Quaternion rotation = Quaternion.identity;
        //the distance will be the minimum distance to an obstacle
        float distance = 0;
        for (int j = 0; j < N-1; j++) {
            // Determine the axis of rotation
            Vector3 axis = Vector3.zero;
            if (j % 3 == 0) {
                axis = Vector3.right; // X axis
            } else if (j % 3 == 1) {
                axis = Vector3.up; // Y axis
            } else {
                axis = Vector3.forward; // Z axis
            }
            // Create rotation for this joint
            Quaternion jointRotation = Quaternion.AngleAxis(angles[j], axis);
            // Accumulate rotation
            rotation *= jointRotation;
            // Update position
            position += rotation * Vector3.up * segmentLength; // Move along local Y axis
            float minDistanceCurrentJoint = distanceObstaclesFromPoint(position);
            //compares to see if it is any smaller than the closest distance yet
            distance = Mathf.Max(minDistanceCurrentJoint, distance);
        }
        print(distance);
        return distance;
    }

    void showArm() {
        //for each angle stored in robotState, it uses the rotation stored in a specific axis only, as a more realistic and factual one would
        for(int j = 0; j < N; j++){
            Vector3 axis = Vector3.zero;
            if (j % 3 == 0) {
                axis = Vector3.right; // X axis
            } else if (j % 3 == 1) {
                axis = Vector3.up; // Y axis
            } else {
                axis = Vector3.forward; // Z axis
            }
            //gets a robotState[j] angle applies in the axis
            Quaternion jointRotation = Quaternion.AngleAxis(robotState[j], axis);
            // Apply the rotation to the corresponding arm part
            armParts[j].transform.localRotation = jointRotation;
        }
    }

    //does the math to calculate the end position given a set of angles
    Vector3 simulatedArm(List<float> evaluated) {
        //the position starts at the base position
        GameObject baseRobot = robot.transform.GetChild(0).gameObject;
        Vector3 position = baseRobot.transform.position;
        //the cumulative rotation starts with the identity
        Quaternion rotation = Quaternion.identity;

        for (int j = 0; j < N; j++) {
            // Determine the axis of rotation
            Vector3 axis = Vector3.zero;
            if (j % 3 == 0) {
                axis = Vector3.right; // X axis
            } else if (j % 3 == 1) {
                axis = Vector3.up; // Y axis
            } else {
                axis = Vector3.forward; // Z axis
            }

            // Create rotation for this joint
            Quaternion jointRotation = Quaternion.AngleAxis(evaluated[j], axis);

            // Accumulate rotation
            rotation *= jointRotation;

            // Update position
            position += rotation * Vector3.up * segmentLength; // Move along local Y axis
        }

        // Return the calculated end effector position
        return position;
    }

    void newPopulation(){
        // Generate new population
        if(generation % 100 == 0) {
            mutRate = Mathf.Max((mutRate + 1) % N, 1);//the mutation keeps changing every 100 generations and it means the number of joint that are gonna be changed
        }
        for (int i = 0; i < popSize; i++){
            for (int j = 0; j < mutRate; j++){
                int idx = Random.Range(0, N);//a random index is generated
                float angle = Random.Range(-maxStep + robotState[idx], maxStep + robotState[idx]);
                popStates[i][idx] = angle;
            }
        }
    }
}