﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using System.Diagnostics;
public class Evolution : MonoBehaviour
{   
    //the pathFinding script
    private PathFinding astarScript;
    //the path generated by the a* that will be used as goals
    private Queue<Node> pathQueue;
    //stopwatch to record the time elapsed during the simulation
    private Stopwatch sw;
    //the filename where the experiment results will be stored in the case of a limited amount of generations
    public string fileName = "experimentLog";
    //the streamWriter to save the log
    private StreamWriter logFile;
    //robot is the whole sctructure created by createScene beggining by the robot's base
    public GameObject robot;
    //the gameobject working as the objective, its 3d position is changed and used for the fitness calculations
    public GameObject goal;
    //this is a list containing the robot's current angles
    private List<float> robotState = new List<float>();
    //this is the population, all the possible solutions for the problem
    private List<List<float>> popStates = new List<List<float>>();

    // Evolution parameters

    //N is the number of joints
    private int N = 0;
    //how many individuals in the same population, to be determined by each experiment configuration
    public int popSize;
    //the maximum possible change in a joint's angulation, the lower the more of a robotic like movement
    public float maxStep;
    //a variable to mark what the current generation is
    private int generation = 1;
    //not used at the moment, its future use will be the speed to change between each point of the path found as the goal
    public int generationsPerObjective = 20;
    //how many generations will be calculated for the experiment, -1 means undefined or neverending simulation
    public int maxGenerations = -1;
    // List of arm parts from CreateScene
    private List<GameObject> armParts;
    //this segmentLength should match distJoint in createScene, as it does in the awake method
    private float segmentLength = 0.4f;
    //just a variable to determine if an individual is better or worse than the previous best one
    private float previousBestfitness;
    public List<GameObject> obstaclesList = new List<GameObject>();

    void Awake(){
        //gets the relevant infos from the createscene and pathFinding script
        N = GetComponent<CreateScene>().N;
        armParts = GetComponent<CreateScene>().armParts;
        segmentLength = GetComponent<CreateScene>().distJoints;
        astarScript = GetComponent<PathFinding>();
        //start to write into the file
        if(maxGenerations != -1) {
            sw = new Stopwatch();   
            logFile = new StreamWriter(fileName, false);
        }
        //initialize the lists with a 0 angulation
        for (int i = 0; i < N; i++){
            robotState.Add(0);
        }
        //iniitialize a random population
        for(int i=0; i<popSize; i++){
            popStates.Add(new List<float>());
            for (int j= 0; j < N; j++){
                float angle = Random.Range(-maxStep + robotState[j], maxStep + robotState[j]);
                popStates[i].Add(angle);
            }
        }
        //disables the script to wait for the pathFinding algorithm to do its job
        this.enabled = false;
    }

    //activates the Update method allowing it to happen, used by the PathFinding script to start the evolution script
    public void activate() {
        this.enabled = true;
        //gets the path found by the a* algorithm and enqueue them into the queue
        pathQueue = new Queue<Node>();
        List<Node> aux = astarScript.answerPath();
        aux.ForEach(pathQueue.Enqueue);
        //already sets the goal as the first element of the path
        goal.transform.position = pathQueue.Dequeue().worldPosition;
        //starts the time count
        if(maxGenerations != -1)
            sw.Start();
    }
    //the never ending loop of evaluating a population, displaying the best configuration and generating a new population based on the previous best one
    void Update(){
        //if this happens, it means it's time to use the next point in the path as the goal and so I update the goal
        if(generation % generationsPerObjective == 0) {
            if(pathQueue.Count != 0) {
                Node aux = pathQueue.Dequeue();
                goal.transform.position = aux.worldPosition;
            }
        }
        fitnessEvaluation();
        showArm();
        newPopulation();
        //prints the generation and best fitness, i intend to make this to be written into a text file for another program to read and plot
        if(maxGenerations != -1) {
            //makes the update method stop when a certain number of generations is reached
            logFile.WriteLine(generation + ", " + previousBestfitness);
            if(generation >= maxGenerations) {
                //writes data to the file and closes it
                endProgram();
            }
        }
        generation++;
    }

    public void addObstacle(GameObject a) {
        obstaclesList.Add(a);
    }
    void endProgram() {
        sw.Stop();
        logFile.WriteLine("Time elapsed(ms): " + sw.ElapsedMilliseconds);
        logFile.WriteLine("Generations: " + maxGenerations);
        logFile.WriteLine("Number of joints: " + N);
        logFile.WriteLine("Population size: " + popSize);
        logFile.WriteLine("MaxStep: " + maxStep);
        logFile.WriteLine("Generations per objective: " + generationsPerObjective);
        logFile.WriteLine("Segment lenght: " + segmentLength);
        logFile.Close();
        logFile.Dispose();
        this.enabled = false;
    }

    void fitnessEvaluation() {
        //the bestInd saves what is the best one in the popStates
        int bestInd = -1;
        //the distance to obstacles is now also taken into account to determine the fitness.
        //this calculation is needed in the case of the goal moving, so that the bestFitness is recalculated, if it were a gloval variable and this wasn't done, it would save a fitness from a different goal or, in other words, another problem
        float bestFitness = Mathf.Min(1/Vector3.Distance(simulatedArm(robotState), goal.transform.position), 4/GetComponent<CreateScene>().distJoints) + Mathf.Min(GetComponent<CreateScene>().distJoints, Mathf.Sqrt(distanceObstacles(robotState)));
        //this fitness calculation takes the distance to objectivo into a max value capped when the distance is smaller than a fourth of the distJoint and tops the distance to obstacles to a max of distJoint so that it wont get any more value of getting further than a joint distance
        for (int i = 0; i < popSize; i++){
            // Test individual arm end position
            Vector3 endPosition = simulatedArm(popStates[i]);
            //calculated the fitness, or distance to the goal
            float fitness = Mathf.Min(1/Vector3.Distance(simulatedArm(popStates[i]), goal.transform.position), 4/GetComponent<CreateScene>().distJoints) + Mathf.Min(GetComponent<CreateScene>().distJoints, Mathf.Sqrt(distanceObstacles(popStates[i])));
            //checks if its better and saves its configuration
            if(fitness > bestFitness){
                bestInd = i;
                bestFitness = fitness;
                robotState = new List<float>(popStates[bestInd]);
            }
        }
        previousBestfitness = bestFitness;
    }

    float distanceObstacles(List<float> angles) {
        if(obstaclesList.Count == 0) return 0; //a 0 value means no obstacle exists and thus it shouldn't be considered
        GameObject baseRobot = robot.transform.GetChild(0).gameObject;
        Vector3 position = baseRobot.transform.position;
        //the cumulative rotation starts with the identity
        Quaternion rotation = Quaternion.identity;
        //the distance will be the minimum distance to an obstacle
        float distance = Mathf.Infinity;
        for (int j = 0; j < N; j++) {
            // Determine the axis of rotation
            Vector3 axis = Vector3.zero;
            if (j % 3 == 0) {
                axis = Vector3.right; // X axis
            } else if (j % 3 == 1) {
                axis = Vector3.up; // Y axis
            } else {
                axis = Vector3.forward; // Z axis
            }
            // Create rotation for this joint
            Quaternion jointRotation = Quaternion.AngleAxis(angles[j], axis);
            // Accumulate rotation
            rotation *= jointRotation;
            // Update position
            position += rotation * Vector3.up * segmentLength; // Move along local Y axis
            float minDistanceCurrentJoint = Mathf.Infinity;
            for(int i = 0; i < obstaclesList.Count; i++) {
                Collider col = obstaclesList[i].GetComponent<Collider>();
                Vector3 closest = col.ClosestPoint(position);
                float cdistance = Vector3.Distance(position, closest);
                minDistanceCurrentJoint = Mathf.Min(minDistanceCurrentJoint, cdistance);//gets the closest distance to an obstacle up from this point
            }
            //compares to see if it is any smaller than the closest distance yet
            distance = Mathf.Min(minDistanceCurrentJoint, distance);
        }
        //returns the smaller one
        return distance;
    }

    void showArm() {
        //for each angle stored in robotState, it uses the rotation stored in a specific axis only, as a more realistic and factual one would
        for(int j = 0; j < N; j++){
            Vector3 axis = Vector3.zero;
            if (j % 3 == 0) {
                axis = Vector3.right; // X axis
            } else if (j % 3 == 1) {
                axis = Vector3.up; // Y axis
            } else {
                axis = Vector3.forward; // Z axis
            }
            //gets a robotState[j] angle applies in the axis
            Quaternion jointRotation = Quaternion.AngleAxis(robotState[j], axis);
            // Apply the rotation to the corresponding arm part
            armParts[j].transform.localRotation = jointRotation;
        }
    }

    //does the math to calculate the end position given a set of angles
    Vector3 simulatedArm(List<float> evaluated) {
        //the position starts at the base position
        GameObject baseRobot = robot.transform.GetChild(0).gameObject;
        Vector3 position = baseRobot.transform.position;
        //the cumulative rotation starts with the identity
        Quaternion rotation = Quaternion.identity;

        for (int j = 0; j < N; j++) {
            // Determine the axis of rotation
            Vector3 axis = Vector3.zero;
            if (j % 3 == 0) {
                axis = Vector3.right; // X axis
            } else if (j % 3 == 1) {
                axis = Vector3.up; // Y axis
            } else {
                axis = Vector3.forward; // Z axis
            }

            // Create rotation for this joint
            Quaternion jointRotation = Quaternion.AngleAxis(evaluated[j], axis);

            // Accumulate rotation
            rotation *= jointRotation;

            // Update position
            position += rotation * Vector3.up * segmentLength; // Move along local Y axis
        }

        // Return the calculated end effector position
        return position;
    }

    void newPopulation(){
        // Generate new population
        for (int i = 0; i < popSize; i++){
            for (int j = 0; j < N; j++){
                float angle = Random.Range(-maxStep + robotState[j], maxStep + robotState[j]);
                popStates[i][j] = angle;
            }
        }
    }
}